/*
 * miniRPC - TCP RPC library with asynchronous operations
 *
 * Copyright (C) 2007-2008 Carnegie Mellon University
 *
 * This code is distributed "AS IS" without warranty of any kind under the
 * terms of the GNU Lesser General Public License version 2.1, as shown in
 * the file COPYING.
 */

/**

@defgroup example Example Protocol
@{
@brief Protocol-dependent API for an example protocol

Much of the miniRPC interface is specific to the application protocol being
implemented on top of miniRPC.  The code to implement this interface is
generated by @c minirpcgen from a ".mx" or protocol definition file.  This
documentation will illustrate the protocol-dependent interfaces using a
simple example protocol.

A protocol definition file describes the data structures and procedure calls
to be supported by the protocol.  The data structures are defined using
XDRL, the External Data Representation Language, defined in
<a href="http://www.ietf.org/rfc/rfc4506.txt">RFC 4506</a>.  The procedure
calls are defined using a syntax specific to miniRPC.

First, we examine the protocol definition for our example protocol.

@section example_mx The example.mx File
@dontinclude example.mx
@until };
@until };

The example protocol starts out by defining an @c example_color enumeration,
and then defines an @c example_color_choice structure which will be used as
the basis of a protocol message.  @c example_color_choice contains a
variable-length array of "acceptable" colors, and one particular color which
is selected as "preferred".

@until example_count

miniRPC presently does not support the use of primitive XDR types as request
or reply arguments to RPC procedures.  A procedure argument must be a named
type corresponding to a struct, enum, or typedef, or must be void.  As here,
if a protocol needs to use a primitive type as a procedure argument, it
must declare and use a typedef for that type.

@until }

We now define the procedure calls to be supported by the server.  Each
procedure can have up to two arguments: one request argument and one reply
argument, in that order.  Unused arguments can be omitted from the procedure
definition or declared to be @c void.  As with @c get_num_colors, a procedure
with a reply argument but no request argument must declare the request argument
to be @c void.  Each procedure is also assigned a procedure number, which is
used by the protocol to indicate which procedure is being called.

Since these procedures are declared in a @c serverprocs section, they are
procedure calls made from client to server; that is, the client is the sender
and the server is the receiver.  There can also be a @c clientprocs section,
which defines procedure calls initiated by the server and received by the
client.

No two procedures in a protocol can have the same name.  No two procedures
of the same type (@c serverprocs, @c clientprocs, @c servermsgs, or
@c clientmsgs) can have the same procedure number.

@until }

This protocol includes an additional @c crayon_selected message, which is not
really a procedure call at all: it is an event notification sent from
client to server, to which the server has no opportunity to reply. (Procedure
calls declared in a @c procs section with a @c void return type, such
as @c choose_color above, still involve a reply, since the receiver can
return a success indication or error code.)  Accordingly, procedure
definitions in the @c msgs section take only a request argument.

As above, messages sent from client to server are defined in a @c servermsgs
section, and messages sent by the server are defined in a @c clientmsgs
section.

@section generation Generating the Protocol Interface

This interface definition is converted into C source and header files by
running:

@verbatim
minirpcgen -o example example.mx
@endverbatim

The result is a set of output files:
- example_client.h
- example_server.h
- example_minirpc.c
- example_minirpc.h
- example_xdr.c
- example_xdr.h

The C source files should be compiled into the programs implementing the
client and server (either directly, or indirectly via a library).  The
header files should also be made available to these programs during their
build process.  A client application implementing this example protocol
need only include example_client.h directly; likewise, a server need
only include example_server.h.

Note that the argument given to @c minirpcgen's @c -o option is embedded
not only in the names of the output files, but in the names of the generated
miniRPC structures and C functions.  (This does not apply to the XDR structs
and enums specified in the @c .mx file.)  If the @c -o option is not
specified, the name of the @c .mx file (with ".mx" removed) is used.

@note If your project uses Make, note that subtle build races can occur when
one Makefile target updates several outputs at once and several @c make jobs
are run in parallel (e.g., with <tt>"make -j3"</tt>).  If you use GNU Make,
you can use pattern rules to properly handle this case:

@note
@verbatim
%_minirpc.c %_minirpc.h %_client.h %_server.h %_xdr.c %_xdr.h: %.mx
	$(MINIRPCGEN) $^
@endverbatim

For more information on the interface generated by @c minirpcgen, see
@ref example_common, @ref example_client, and @ref example_server.  For
example code using this protocol, see @ref example_client_prog and
@ref example_server_prog.

@section minirpcgen_advanced Advanced minirpcgen

@subsection minirpcgen_passes Compile Passes

@c minirpcgen generates output in three passes.  The <tt>*_xdr.c</tt> and
<tt>*_xdr.h</tt> files are generated by the @c rpcgen program in two separate
passes; the rest of the output files are generated by @c minirpcgen itself.

As a result, parse errors may be issued at several points in the compile
process.  @c minirpcgen itself will issue errors relating to procedure
definition blocks, while @c rpcgen will issue errors relating to XDR data type
definitions.  @c rpcgen does not attempt to catch all type definition errors
directly, so some errors may only appear once the C compiler attempts to
compile the generated code.

@subsection minirpcgen_cpp Using cpp

<tt>.mx</tt> files are preprocessed using @c cpp before they are read, so all
of the usual preprocessor directives (@c \#include, etc.) work as expected.
@c minirpcgen defines special preprocessor macros during each pass over the
input file:

- @c RPC_XDR is defined when generating <tt>*_xdr.c</tt>
- @c RPC_HDR is defined when generating <tt>*_xdr.h</tt>
- @c MINIRPC is defined when generating all other output files

For the XDR passes @em only, you can embed literal strings in the output files
by prefixing them with "%". Using both literal strings and defines it is
possible to declare common data structures in a @c .mx file and include it
into several others with the following fragment:

@verbatim
#ifdef MINIRPC
#include "common.mx"
#else
%#include "common_xdr.h"
#endif
@endverbatim

You can define additional preprocessor macros by passing <tt>"-D
MACRONAME=value"</tt> to @c minirpcgen.  Multiple @c -D options are accepted.

@defgroup example_common Common Definitions
@defgroup example_client Client Stubs
@defgroup example_server Server Stubs

For prototypes and documentation for the server RPC handlers, see
::example_server_operations.

@addtogroup example
@}


@page example_client_prog Example Client Program

Here is a simple synchronous client for the protocol defined in
@ref example_mx.  Note that this client does not use advanced features such
as asynchronous operation.

@include example_client.c


@page example_server_prog Example Server Program

Here is a simple synchronous server for the protocol defined in
@ref example_mx.  Note that this server does not use advanced features such
as asynchronous operation.

@include example_server.c
*/
*/
