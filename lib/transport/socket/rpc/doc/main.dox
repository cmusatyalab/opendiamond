/*
 * miniRPC - TCP RPC library with asynchronous operations
 *
 * Copyright (C) 2007-2008 Carnegie Mellon University
 *
 * This code is distributed "AS IS" without warranty of any kind under the
 * terms of the GNU Lesser General Public License version 2.1, as shown in
 * the file COPYING.
 */

/**

@mainpage miniRPC: A TCP Remote Procedure Call Library

@section about About miniRPC

miniRPC is a remote procedure call library which works on top of TCP and other
stream-oriented transports.  It has the following design goals:

- Simple on-the-wire protocol
- Scalability to large numbers of connections
- Automatic stub generation
- No use of a portmapper: clients connect directly to the well-known port for
a service
- Simple usage model for synchronous RPCs
- Straightforward support for asynchronous RPCs, including out-of-order
replies, at both client and server
- Application-defined event loop
- Support for bidirectional communication: both the client and the server can
initiate RPCs
- Support for event notifications, which do not require a reply
- Support for multi-threaded operation with an application-defined threading
model
- Support for multiple RPC protocols and protocol roles in a single process
- Support for TLS encryption (currently unimplemented)

@section terms miniRPC Terminology

- A miniRPC @em connection is a single network connection between two
endpoints which carries miniRPC traffic.

- The @em server is the host which listens for incoming connections.  The
@em client is the host which initiates a connection to a server.

- The @em sender of an RPC is the party which initiates an RPC or transmits
an event message.  The @em receiver is the party which receives the message
and (if applicable) sends a reply.

- A @em protocol is an application-specific set of remote procedures and data
structures which define communication on the wire.  miniRPC is a framework
for implementing these protocols.  The
<a href="http://www.ietf.org/rfc/rfc4506.txt">XDR</a> serialization format
used by miniRPC is not self-describing, so both parties to a miniRPC connection
need to know the protocol being used.

- Every protocol has two <em>protocol roles</em>: client and server.  These
define the reponsibilities of a particular connection endpoint.  For example,
a particular connection might be a <em>foo client</em>: a client using the
@em foo protocol.

- A <em>connection set</em> is a container for connections which provides
infrastructure (for example, event handling) and some shared configuration
values.  All connections in a connection set must have the same protocol
role.  Each connection is associated with exactly one connection set.

- @em Synchronous RPC calls are those which block until the RPC is complete.
@em Sender-asynchronous calls are those in which the sender does not block; it
is notified via a callback function when the RPC reply is received.
@em Receiver-asynchronous calls are those where the receiver's event handler
returns before the call has been completely processed; the receiver transmits
its reply at a later time using a stub function provided for that purpose.
An RPC can be both sender- and receiver-asynchronous.  Note that
these are properties of the @em implementation; the on-the-wire format
does not distinguish between synchronous and asynchronous RPCs.

@section structure Structure of the miniRPC Library

Applications using miniRPC interact with three different interfaces.
@c minirpcgen is the stub generator for miniRPC; it reads a description
of the application-specific protocol, and generates C structures and
functions corresponding to the protocol definition.  The C files
generated by @c minirpcgen implement the @ref example "protocol-dependent"
portion of the miniRPC interface, and must be compiled into the client
and server applications.  miniRPC also provides a @ref common
"protocol-independent" interface for common tasks such as @ref setup
"library initialization", @ref conn "connection setup and teardown", and
@ref event "event handling".

*/
